(declare-rel fail ())
(declare-rel hashfunc (Bool Bool Int Int Int Int))
(declare-rel main (Bool Bool Int Int Int Int Int Int Int Int))
(declare-var p1 Bool)
(declare-var input1 Int)
(declare-var res1 Int)
(declare-var hash1 Int)
(declare-var l1 Int)
(declare-var l1_i Int)
(declare-var t1 Bool)
(declare-var f1 Bool)
(declare-var secret1 Int)
(declare-var p2 Bool)
(declare-var input2 Int)
(declare-var res2 Int)
(declare-var hash2 Int)
(declare-var l2 Int)
(declare-var l2_i Int)
(declare-var t2 Bool)
(declare-var f2 Bool)
(declare-var secret2 Int)

(rule (hashfunc p1 p2 input1 input2 res1 res2))

(rule (=> (and
  (=> p1 (= l1 0))
  (=> p2 (= l2 0))
  (or p1 p2)
  (hashfunc p1 p2 input1 input2 res1 res2)
  (=> (and p1 p2) (=
        (ite (= hash1 res1) secret1 0)
        (ite (= hash2 res2) secret2 0)))
  ; declassify hashfunc(input) == hash ? secret : 0
  (= t1 (and p1 (= hash1 res1)))
  (= t2 (and p2 (= hash2 res2)))
  (= f1 (and p1 (not (= hash1 res1))))
  (= f2 (and p2 (not (= hash2 res2))))
  (=> t1 (= l1_i secret1))
  (=> t2 (= l2_i secret2))
  (=> f1 (= l1_i l1))
  (=> f2 (= l2_i l2)))
  (main p1 p2 secret1 secret2 hash1 hash2 input1 input2 l1_i l2_i)))

(rule (=> (and
  (=> (and p1 p2) (= input1 input2))
  (main p1 p2 secret1 secret1 hash1 hash2 input1 input2 l1 l2)
  (not (=> (and p1 p2) (= l1 l2))))
  fail))

(query fail)
